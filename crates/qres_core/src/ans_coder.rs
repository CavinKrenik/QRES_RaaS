//! Deterministic Static Range Coder
//!
//! Uses a fixed Laplace distribution model optimized for prediction residuals.
//! Guarantees O(1) encoding, zero adaptive state, and bit-identical output
//! across x86/ARM/WASM architectures.
//!
//! Generated frequency table: tools/dev/generate_laplace_table.py

use alloc::vec::Vec;

// --- Constants ---
const FREQ_BITS: u32 = 16;
const FREQ_TOTAL: u32 = 1 << FREQ_BITS; // 65536
const TOP: u32 = 1 << 24;
const BOT: u32 = 1 << 16;

// Generated by tools/dev/generate_laplace_table.py
// Parameters: FREQ_TOTAL=65536, SCALE=10.0
// Format: (cumulative_frequency, symbol_frequency)
#[rustfmt::skip]
static CUM_FREQ_TABLE: [(u32, u32); 256] = [
    (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1),             // -128..-121
    (8, 1), (9, 1), (10, 1), (11, 1), (12, 1), (13, 1), (14, 1), (15, 1),       // -120..-113
    (16, 1), (17, 1), (18, 1), (19, 1), (20, 1), (21, 1), (22, 1), (23, 1),     // -112..-105
    (24, 1), (25, 1), (26, 1), (27, 1), (28, 1), (29, 1), (30, 1), (31, 1),     // -104..-97
    (32, 1), (33, 1), (34, 1), (35, 1), (36, 1), (37, 1), (38, 1), (39, 1),     // -96..-89
    (40, 1), (41, 1), (42, 1), (43, 1), (44, 1), (45, 1), (46, 1), (47, 1),     // -88..-81
    (48, 1), (49, 1), (50, 1), (51, 1), (52, 1), (53, 1), (54, 2), (56, 2),     // -80..-73
    (58, 2), (60, 2), (62, 2), (64, 3), (67, 3), (70, 4), (74, 4), (78, 4),     // -72..-65
    (82, 5), (87, 6), (93, 6), (99, 7), (106, 8), (114, 8), (122, 9), (131, 10),// -64..-57
    (141, 12), (153, 13), (166, 14), (180, 16), (196, 18), (214, 19), (233, 22), (255, 24), // -56..-49
    (279, 26), (305, 29), (334, 32), (366, 36), (402, 40), (442, 44), (486, 49), (535, 54), // -48..-41
    (589, 59), (648, 66), (714, 73), (787, 80), (867, 89), (956, 98), (1054, 109), (1163, 120), // -40..-33
    (1283, 133), (1416, 147), (1563, 163), (1726, 180), (1906, 199), (2105, 220), (2325, 243), (2568, 268), // -32..-25
    (2836, 297), (3133, 328), (3461, 362), (3823, 400), (4223, 443), (4666, 489), (5155, 541), (5696, 598), // -24..-17
    (6294, 661), (6955, 730), (7685, 807), (8492, 892), (9384, 986), (10370, 1089), (11459, 1204), (12663, 1331), // -16..-9
    (13994, 1471), (15465, 1625), (17090, 1796), (18886, 1985), (20871, 2194), (23065, 2425), (25490, 2680), (28170, 2962), // -8..-1
    (31132, 3273), // 0 (CENTER - highest freq)
    (34405, 2962), (37367, 2680), (40047, 2425), (42472, 2194), (44666, 1985), (46651, 1796), (48447, 1625), // +1..+7
    (50072, 1471), (51543, 1331), (52874, 1204), (54078, 1089), (55167, 986), (56153, 892), (57045, 807), (57852, 730), // +8..+15
    (58582, 661), (59243, 598), (59841, 541), (60382, 489), (60871, 443), (61314, 400), (61714, 362), (62076, 328), // +16..+23
    (62404, 297), (62701, 268), (62969, 243), (63212, 220), (63432, 199), (63631, 180), (63811, 163), (63974, 147), // +24..+31
    (64121, 133), (64254, 120), (64374, 109), (64483, 98), (64581, 89), (64670, 80), (64750, 73), (64823, 66), // +32..+39
    (64889, 59), (64948, 54), (65002, 49), (65051, 44), (65095, 40), (65135, 36), (65171, 32), (65203, 29), // +40..+47
    (65232, 26), (65258, 24), (65282, 22), (65304, 19), (65323, 18), (65341, 16), (65357, 14), (65371, 13), // +48..+55
    (65384, 12), (65396, 10), (65406, 9), (65415, 8), (65423, 8), (65431, 7), (65438, 6), (65444, 6), // +56..+63
    (65450, 5), (65455, 4), (65459, 4), (65463, 4), (65467, 3), (65470, 3), (65473, 2), (65475, 2), // +64..+71
    (65477, 2), (65479, 2), (65481, 2), (65483, 1), (65484, 1), (65485, 1), (65486, 1), (65487, 1), // +72..+79
    (65488, 1), (65489, 1), (65490, 1), (65491, 1), (65492, 1), (65493, 1), (65494, 1), (65495, 1), // +80..+87
    (65496, 1), (65497, 1), (65498, 1), (65499, 1), (65500, 1), (65501, 1), (65502, 1), (65503, 1), // +88..+95
    (65504, 1), (65505, 1), (65506, 1), (65507, 1), (65508, 1), (65509, 1), (65510, 1), (65511, 1), // +96..+103
    (65512, 1), (65513, 1), (65514, 1), (65515, 1), (65516, 1), (65517, 1), (65518, 1), (65519, 1), // +104..+111
    (65520, 1), (65521, 1), (65522, 1), (65523, 1), (65524, 1), (65525, 1), (65526, 1), (65527, 1), // +112..+119
    (65528, 1), (65529, 1), (65530, 1), (65531, 1), (65532, 1), (65533, 1), (65534, 1), (65535, 1), // +120..+127
];
// Verification: cumulative sum = 65536 (expected 65536)

/// Binary search to find symbol from cumulative frequency
#[inline]
fn find_symbol(target: u32) -> u8 {
    let mut lo = 0usize;
    let mut hi = 255usize;
    while lo < hi {
        let mid = (lo + hi + 1) >> 1;
        if CUM_FREQ_TABLE[mid].0 <= target {
            lo = mid;
        } else {
            hi = mid - 1;
        }
    }
    lo as u8
}

// ============================================================================
// ENCODER
// ============================================================================

pub struct AnsWriter {
    low: u64,
    range: u32,
    buffer: Vec<u8>,
}

impl Default for AnsWriter {
    fn default() -> Self {
        Self::new()
    }
}

impl AnsWriter {
    pub fn new() -> Self {
        Self {
            low: 0,
            range: 0xFFFF_FFFF,
            buffer: Vec::with_capacity(4096),
        }
    }

    #[inline]
    pub fn write_residual(&mut self, residual: i8) {
        // Map i8 (-128..127) to u8 (0..255)
        let symbol = (residual as i16 + 128) as u8;
        let (cum, freq) = CUM_FREQ_TABLE[symbol as usize];

        // Range encode: narrow interval
        self.range /= FREQ_TOTAL;
        self.low += (self.range as u64) * (cum as u64);
        self.range *= freq;

        // Renormalize
        self.normalize();
    }

    #[inline]
    fn normalize(&mut self) {
        loop {
            if (self.low ^ (self.low + self.range as u64)) >= (TOP as u64) {
                if self.range >= BOT {
                    break;
                }
                // Force range to next byte boundary
                self.range = (!(self.low as u32)) & (BOT - 1);
            }
            self.buffer.push((self.low >> 24) as u8);
            self.low <<= 8;
            self.range <<= 8;
        }
    }

    pub fn finish(mut self) -> Vec<u8> {
        // Flush 4 bytes of state
        for _ in 0..4 {
            self.buffer.push((self.low >> 24) as u8);
            self.low <<= 8;
        }
        self.buffer
    }
}

// ============================================================================
// DECODER
// ============================================================================

pub struct AnsReader {
    data: Vec<u8>,
    pos: usize,
    low: u32,
    range: u32,
    code: u32,
}

impl AnsReader {
    pub fn new(data: &[u8]) -> Self {
        let mut reader = Self {
            data: data.to_vec(),
            pos: 0,
            low: 0,
            range: 0xFFFF_FFFF,
            code: 0,
        };
        // Initialize code from first 4 bytes
        for _ in 0..4 {
            reader.code = (reader.code << 8) | reader.read_byte() as u32;
        }
        reader
    }

    #[inline]
    fn read_byte(&mut self) -> u8 {
        if self.pos < self.data.len() {
            let b = self.data[self.pos];
            self.pos += 1;
            b
        } else {
            0
        }
    }

    #[inline]
    pub fn read_residual(&mut self) -> i8 {
        // Compute target frequency
        let r = self.range / FREQ_TOTAL;
        let target = (self.code.wrapping_sub(self.low)) / r;
        let target = target.min(FREQ_TOTAL - 1);

        // Find symbol via binary search
        let symbol = find_symbol(target);
        let (cum, freq) = CUM_FREQ_TABLE[symbol as usize];

        // Update decoder state (must match encoder exactly)
        self.range /= FREQ_TOTAL;
        self.low = self.low.wrapping_add(self.range.wrapping_mul(cum));
        self.range = self.range.wrapping_mul(freq);

        // Renormalize
        self.normalize();

        // Map u8 (0..255) back to i8 (-128..127)
        (symbol as i16 - 128) as i8
    }

    #[inline]
    fn normalize(&mut self) {
        loop {
            if (self.low ^ (self.low.wrapping_add(self.range))) >= TOP {
                if self.range >= BOT {
                    break;
                }
                self.range = (!self.low) & (BOT - 1);
            }
            self.code = (self.code << 8) | self.read_byte() as u32;
            self.low <<= 8;
            self.range <<= 8;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn roundtrip_zero() {
        let mut w = AnsWriter::new();
        w.write_residual(0);
        let encoded = w.finish();

        let mut r = AnsReader::new(&encoded);
        assert_eq!(r.read_residual(), 0);
    }

    #[test]
    fn roundtrip_sequence() {
        let residuals: Vec<i8> = vec![0, 1, -1, 2, -2, 10, -10, 50, -50, 127, -128];

        let mut w = AnsWriter::new();
        for &res in &residuals {
            w.write_residual(res);
        }
        let encoded = w.finish();

        let mut r = AnsReader::new(&encoded);
        for &expected in &residuals {
            assert_eq!(r.read_residual(), expected);
        }
    }

    #[test]
    fn roundtrip_all_values() {
        // Test every possible i8 value
        let mut w = AnsWriter::new();
        for i in -128i8..=127i8 {
            w.write_residual(i);
        }
        let encoded = w.finish();

        let mut r = AnsReader::new(&encoded);
        for i in -128i8..=127i8 {
            assert_eq!(r.read_residual(), i, "Mismatch at {}", i);
        }
    }

    #[test]
    fn compression_ratio_zeros() {
        // 1000 zeros should compress well (high probability for 0)
        let mut w = AnsWriter::new();
        for _ in 0..1000 {
            w.write_residual(0);
        }
        let encoded = w.finish();

        // 0 has freq 3273/65536 ≈ 5%, so ~4.3 bits per symbol
        // 1000 * 4.3 / 8 ≈ 537 bytes, plus 4 byte flush overhead
        assert!(
            encoded.len() < 600,
            "Expected compression for zeros, got {} bytes",
            encoded.len()
        );
    }

    #[test]
    fn compression_ratio_small_residuals() {
        // Small residuals near 0 should compress well
        let mut w = AnsWriter::new();
        for i in 0..1000 {
            let residual = ((i % 5) as i8) - 2; // -2, -1, 0, 1, 2 pattern
            w.write_residual(residual);
        }
        let encoded = w.finish();

        // Should be well under 1000 bytes
        assert!(
            encoded.len() < 800,
            "Expected compression for small residuals, got {} bytes",
            encoded.len()
        );
    }
}
